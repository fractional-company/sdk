/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type LPDAInfoStruct = {
  startTime: PromiseOrValue<BigNumberish>;
  endTime: PromiseOrValue<BigNumberish>;
  dropPerSecond: PromiseOrValue<BigNumberish>;
  startPrice: PromiseOrValue<BigNumberish>;
  endPrice: PromiseOrValue<BigNumberish>;
  minBid: PromiseOrValue<BigNumberish>;
  supply: PromiseOrValue<BigNumberish>;
  numSold: PromiseOrValue<BigNumberish>;
  curatorClaimed: PromiseOrValue<BigNumberish>;
  curator: PromiseOrValue<string>;
};

export type LPDAInfoStructOutput = [
  number,
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  number,
  number,
  BigNumber,
  string
] & {
  startTime: number;
  endTime: number;
  dropPerSecond: BigNumber;
  startPrice: BigNumber;
  endPrice: BigNumber;
  minBid: BigNumber;
  supply: number;
  numSold: number;
  curatorClaimed: BigNumber;
  curator: string;
};

export type PermissionStruct = {
  module: PromiseOrValue<string>;
  target: PromiseOrValue<string>;
  selector: PromiseOrValue<BytesLike>;
};

export type PermissionStructOutput = [string, string, string] & {
  module: string;
  target: string;
  selector: string;
};

export interface LPDAInterface extends utils.Interface {
  functions: {
    "MAX_FEE()": FunctionFragment;
    "WETH_ADDRESS()": FunctionFragment;
    "balanceContributed(address,address)": FunctionFragment;
    "balanceRefunded(address,address)": FunctionFragment;
    "currentPrice(address)": FunctionFragment;
    "deployVault(address[],address[],bytes4[],(uint32,uint32,uint64,uint128,uint128,uint128,uint16,uint16,uint128,address),address,uint256,bytes32[])": FunctionFragment;
    "enterBid(address,uint16)": FunctionFragment;
    "feeReceiver()": FunctionFragment;
    "generateMerkleTree(address[])": FunctionFragment;
    "generateUnhashedMerkleTree(address[])": FunctionFragment;
    "getAuctionState(address)": FunctionFragment;
    "getLeaves()": FunctionFragment;
    "getMinters(address)": FunctionFragment;
    "getPermissions()": FunctionFragment;
    "getProof(bytes32[],uint256)": FunctionFragment;
    "getRoot(bytes32[])": FunctionFragment;
    "getUnhashedLeaves()": FunctionFragment;
    "hashLeafPairs(bytes32,bytes32)": FunctionFragment;
    "log2ceil_naive(uint256)": FunctionFragment;
    "numMinted(address,address)": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "redeemNFTCurator(address,address,uint256,bytes32[])": FunctionFragment;
    "refundOwed(address,address)": FunctionFragment;
    "registry()": FunctionFragment;
    "settleAddress(address,address)": FunctionFragment;
    "settleCurator(address)": FunctionFragment;
    "supply()": FunctionFragment;
    "transfer()": FunctionFragment;
    "updateFeeReceiver(address)": FunctionFragment;
    "vaultLPDAInfo(address)": FunctionFragment;
    "vaultLPDAMinters(address,uint256)": FunctionFragment;
    "vaultRoyaltyToken(address)": FunctionFragment;
    "vaultRoyaltyTokenId(address)": FunctionFragment;
    "verifyProof(bytes32,bytes32[],bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAX_FEE"
      | "WETH_ADDRESS"
      | "balanceContributed"
      | "balanceRefunded"
      | "currentPrice"
      | "deployVault"
      | "enterBid"
      | "feeReceiver"
      | "generateMerkleTree"
      | "generateUnhashedMerkleTree"
      | "getAuctionState"
      | "getLeaves"
      | "getMinters"
      | "getPermissions"
      | "getProof"
      | "getRoot"
      | "getUnhashedLeaves"
      | "hashLeafPairs"
      | "log2ceil_naive"
      | "numMinted"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "onERC721Received"
      | "redeemNFTCurator"
      | "refundOwed"
      | "registry"
      | "settleAddress"
      | "settleCurator"
      | "supply"
      | "transfer"
      | "updateFeeReceiver"
      | "vaultLPDAInfo"
      | "vaultLPDAMinters"
      | "vaultRoyaltyToken"
      | "vaultRoyaltyTokenId"
      | "verifyProof"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "MAX_FEE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "WETH_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "balanceContributed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceRefunded",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "currentPrice",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "deployVault",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BytesLike>[],
      LPDAInfoStruct,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "enterBid",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "feeReceiver",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "generateMerkleTree",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "generateUnhashedMerkleTree",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getAuctionState",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "getLeaves", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getMinters",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPermissions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProof",
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoot",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getUnhashedLeaves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hashLeafPairs",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "log2ceil_naive",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "numMinted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemNFTCurator",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "refundOwed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "registry", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "settleAddress",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "settleCurator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "supply", values?: undefined): string;
  encodeFunctionData(functionFragment: "transfer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateFeeReceiver",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultLPDAInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultLPDAMinters",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultRoyaltyToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultRoyaltyTokenId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyProof",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "MAX_FEE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "WETH_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceContributed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceRefunded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "enterBid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "generateMerkleTree",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "generateUnhashedMerkleTree",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAuctionState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getLeaves", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMinters", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPermissions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getProof", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getRoot", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUnhashedLeaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hashLeafPairs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "log2ceil_naive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "numMinted", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemNFTCurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "refundOwed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "registry", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "settleAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleCurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "supply", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateFeeReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultLPDAInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultLPDAMinters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultRoyaltyToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultRoyaltyTokenId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyProof",
    data: BytesLike
  ): Result;

  events: {
    "ActiveModules(address,address[])": EventFragment;
    "BidEntered(address,address,uint256,uint256)": EventFragment;
    "CreatedLPDA(address,address,uint256,tuple)": EventFragment;
    "CuratorClaimed(address,address,uint256)": EventFragment;
    "CuratorRedeemedNFT(address,address,address,uint256)": EventFragment;
    "FeeDispersed(address,address,uint256)": EventFragment;
    "MintedRaes(address,address,uint256,uint256)": EventFragment;
    "Refunded(address,address,uint256)": EventFragment;
    "RoyaltyPaid(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ActiveModules"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BidEntered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatedLPDA"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CuratorClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CuratorRedeemedNFT"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FeeDispersed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintedRaes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Refunded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltyPaid"): EventFragment;
}

export interface ActiveModulesEventObject {
  _vault: string;
  _modules: string[];
}
export type ActiveModulesEvent = TypedEvent<
  [string, string[]],
  ActiveModulesEventObject
>;

export type ActiveModulesEventFilter = TypedEventFilter<ActiveModulesEvent>;

export interface BidEnteredEventObject {
  _vault: string;
  _user: string;
  _quantity: BigNumber;
  _price: BigNumber;
}
export type BidEnteredEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  BidEnteredEventObject
>;

export type BidEnteredEventFilter = TypedEventFilter<BidEnteredEvent>;

export interface CreatedLPDAEventObject {
  _vault: string;
  _token: string;
  _id: BigNumber;
  _lpdaInfo: LPDAInfoStructOutput;
}
export type CreatedLPDAEvent = TypedEvent<
  [string, string, BigNumber, LPDAInfoStructOutput],
  CreatedLPDAEventObject
>;

export type CreatedLPDAEventFilter = TypedEventFilter<CreatedLPDAEvent>;

export interface CuratorClaimedEventObject {
  _vault: string;
  _curator: string;
  _amount: BigNumber;
}
export type CuratorClaimedEvent = TypedEvent<
  [string, string, BigNumber],
  CuratorClaimedEventObject
>;

export type CuratorClaimedEventFilter = TypedEventFilter<CuratorClaimedEvent>;

export interface CuratorRedeemedNFTEventObject {
  _vault: string;
  _curator: string;
  _token: string;
  _tokenId: BigNumber;
}
export type CuratorRedeemedNFTEvent = TypedEvent<
  [string, string, string, BigNumber],
  CuratorRedeemedNFTEventObject
>;

export type CuratorRedeemedNFTEventFilter =
  TypedEventFilter<CuratorRedeemedNFTEvent>;

export interface FeeDispersedEventObject {
  _vault: string;
  _receiver: string;
  _amount: BigNumber;
}
export type FeeDispersedEvent = TypedEvent<
  [string, string, BigNumber],
  FeeDispersedEventObject
>;

export type FeeDispersedEventFilter = TypedEventFilter<FeeDispersedEvent>;

export interface MintedRaesEventObject {
  _vault: string;
  _user: string;
  _quantity: BigNumber;
  _price: BigNumber;
}
export type MintedRaesEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  MintedRaesEventObject
>;

export type MintedRaesEventFilter = TypedEventFilter<MintedRaesEvent>;

export interface RefundedEventObject {
  _vault: string;
  _user: string;
  _balance: BigNumber;
}
export type RefundedEvent = TypedEvent<
  [string, string, BigNumber],
  RefundedEventObject
>;

export type RefundedEventFilter = TypedEventFilter<RefundedEvent>;

export interface RoyaltyPaidEventObject {
  _vault: string;
  _royaltyReceiver: string;
  _amount: BigNumber;
}
export type RoyaltyPaidEvent = TypedEvent<
  [string, string, BigNumber],
  RoyaltyPaidEventObject
>;

export type RoyaltyPaidEventFilter = TypedEventFilter<RoyaltyPaidEvent>;

export interface LPDA extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LPDAInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    WETH_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    balanceContributed(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceRefunded(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    currentPrice(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { price: BigNumber }>;

    deployVault(
      _modules: PromiseOrValue<string>[],
      _plugins: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      _lpdaInfo: LPDAInfoStruct,
      _token: PromiseOrValue<string>,
      _id: PromiseOrValue<BigNumberish>,
      _mintProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enterBid(
      _vault: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    feeReceiver(overrides?: CallOverrides): Promise<[string]>;

    generateMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { tree: string[] }>;

    generateUnhashedMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<[string[]] & { tree: string[] }>;

    getAuctionState(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getLeaves(
      overrides?: CallOverrides
    ): Promise<[string[]] & { leaves: string[] }>;

    getMinters(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getPermissions(
      overrides?: CallOverrides
    ): Promise<
      [PermissionStructOutput[]] & { permissions: PermissionStructOutput[] }
    >;

    getProof(
      _data: PromiseOrValue<BytesLike>[],
      _node: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { proof: string[] }>;

    getRoot(
      _data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[string]>;

    getUnhashedLeaves(
      overrides?: CallOverrides
    ): Promise<[string[]] & { leaves: string[] }>;

    hashLeafPairs(
      _left: PromiseOrValue<BytesLike>,
      _right: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { data: string }>;

    log2ceil_naive(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { ceil: BigNumber }>;

    numMinted(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redeemNFTCurator(
      _vault: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _tokenId: PromiseOrValue<BigNumberish>,
      _erc721TransferProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    refundOwed(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    registry(overrides?: CallOverrides): Promise<[string]>;

    settleAddress(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    settleCurator(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supply(overrides?: CallOverrides): Promise<[string]>;

    transfer(overrides?: CallOverrides): Promise<[string]>;

    updateFeeReceiver(
      _receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    vaultLPDAInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        number,
        BigNumber,
        string
      ] & {
        startTime: number;
        endTime: number;
        dropPerSecond: BigNumber;
        startPrice: BigNumber;
        endPrice: BigNumber;
        minBid: BigNumber;
        supply: number;
        numSold: number;
        curatorClaimed: BigNumber;
        curator: string;
      }
    >;

    vaultLPDAMinters(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    vaultRoyaltyToken(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    vaultRoyaltyTokenId(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    verifyProof(
      _root: PromiseOrValue<BytesLike>,
      _proof: PromiseOrValue<BytesLike>[],
      _valueToProve: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;

  WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

  balanceContributed(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceRefunded(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  currentPrice(
    _vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  deployVault(
    _modules: PromiseOrValue<string>[],
    _plugins: PromiseOrValue<string>[],
    _selectors: PromiseOrValue<BytesLike>[],
    _lpdaInfo: LPDAInfoStruct,
    _token: PromiseOrValue<string>,
    _id: PromiseOrValue<BigNumberish>,
    _mintProof: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enterBid(
    _vault: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  feeReceiver(overrides?: CallOverrides): Promise<string>;

  generateMerkleTree(
    _modules: PromiseOrValue<string>[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  generateUnhashedMerkleTree(
    _modules: PromiseOrValue<string>[],
    overrides?: CallOverrides
  ): Promise<string[]>;

  getAuctionState(
    _vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  getLeaves(overrides?: CallOverrides): Promise<string[]>;

  getMinters(
    _vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getPermissions(overrides?: CallOverrides): Promise<PermissionStructOutput[]>;

  getProof(
    _data: PromiseOrValue<BytesLike>[],
    _node: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getRoot(
    _data: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<string>;

  getUnhashedLeaves(overrides?: CallOverrides): Promise<string[]>;

  hashLeafPairs(
    _left: PromiseOrValue<BytesLike>,
    _right: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  log2ceil_naive(
    x: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  numMinted(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  onERC1155BatchReceived(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>[],
    arg3: PromiseOrValue<BigNumberish>[],
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  redeemNFTCurator(
    _vault: PromiseOrValue<string>,
    _token: PromiseOrValue<string>,
    _tokenId: PromiseOrValue<BigNumberish>,
    _erc721TransferProof: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  refundOwed(
    _vault: PromiseOrValue<string>,
    _minter: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  registry(overrides?: CallOverrides): Promise<string>;

  settleAddress(
    _vault: PromiseOrValue<string>,
    _minter: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  settleCurator(
    _vault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supply(overrides?: CallOverrides): Promise<string>;

  transfer(overrides?: CallOverrides): Promise<string>;

  updateFeeReceiver(
    _receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  vaultLPDAInfo(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      number,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      number,
      BigNumber,
      string
    ] & {
      startTime: number;
      endTime: number;
      dropPerSecond: BigNumber;
      startPrice: BigNumber;
      endPrice: BigNumber;
      minBid: BigNumber;
      supply: number;
      numSold: number;
      curatorClaimed: BigNumber;
      curator: string;
    }
  >;

  vaultLPDAMinters(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  vaultRoyaltyToken(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  vaultRoyaltyTokenId(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  verifyProof(
    _root: PromiseOrValue<BytesLike>,
    _proof: PromiseOrValue<BytesLike>[],
    _valueToProve: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

    balanceContributed(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceRefunded(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentPrice(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deployVault(
      _modules: PromiseOrValue<string>[],
      _plugins: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      _lpdaInfo: LPDAInfoStruct,
      _token: PromiseOrValue<string>,
      _id: PromiseOrValue<BigNumberish>,
      _mintProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string>;

    enterBid(
      _vault: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    feeReceiver(overrides?: CallOverrides): Promise<string>;

    generateMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    generateUnhashedMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    getAuctionState(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    getLeaves(overrides?: CallOverrides): Promise<string[]>;

    getMinters(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getPermissions(
      overrides?: CallOverrides
    ): Promise<PermissionStructOutput[]>;

    getProof(
      _data: PromiseOrValue<BytesLike>[],
      _node: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getRoot(
      _data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string>;

    getUnhashedLeaves(overrides?: CallOverrides): Promise<string[]>;

    hashLeafPairs(
      _left: PromiseOrValue<BytesLike>,
      _right: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    log2ceil_naive(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    numMinted(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    redeemNFTCurator(
      _vault: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _tokenId: PromiseOrValue<BigNumberish>,
      _erc721TransferProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    refundOwed(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    registry(overrides?: CallOverrides): Promise<string>;

    settleAddress(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    settleCurator(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    supply(overrides?: CallOverrides): Promise<string>;

    transfer(overrides?: CallOverrides): Promise<string>;

    updateFeeReceiver(
      _receiver: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    vaultLPDAInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        number,
        BigNumber,
        string
      ] & {
        startTime: number;
        endTime: number;
        dropPerSecond: BigNumber;
        startPrice: BigNumber;
        endPrice: BigNumber;
        minBid: BigNumber;
        supply: number;
        numSold: number;
        curatorClaimed: BigNumber;
        curator: string;
      }
    >;

    vaultLPDAMinters(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    vaultRoyaltyToken(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    vaultRoyaltyTokenId(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyProof(
      _root: PromiseOrValue<BytesLike>,
      _proof: PromiseOrValue<BytesLike>[],
      _valueToProve: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "ActiveModules(address,address[])"(
      _vault?: PromiseOrValue<string> | null,
      _modules?: null
    ): ActiveModulesEventFilter;
    ActiveModules(
      _vault?: PromiseOrValue<string> | null,
      _modules?: null
    ): ActiveModulesEventFilter;

    "BidEntered(address,address,uint256,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _quantity?: null,
      _price?: null
    ): BidEnteredEventFilter;
    BidEntered(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _quantity?: null,
      _price?: null
    ): BidEnteredEventFilter;

    "CreatedLPDA(address,address,uint256,tuple)"(
      _vault?: PromiseOrValue<string> | null,
      _token?: PromiseOrValue<string> | null,
      _id?: null,
      _lpdaInfo?: null
    ): CreatedLPDAEventFilter;
    CreatedLPDA(
      _vault?: PromiseOrValue<string> | null,
      _token?: PromiseOrValue<string> | null,
      _id?: null,
      _lpdaInfo?: null
    ): CreatedLPDAEventFilter;

    "CuratorClaimed(address,address,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _curator?: PromiseOrValue<string> | null,
      _amount?: null
    ): CuratorClaimedEventFilter;
    CuratorClaimed(
      _vault?: PromiseOrValue<string> | null,
      _curator?: PromiseOrValue<string> | null,
      _amount?: null
    ): CuratorClaimedEventFilter;

    "CuratorRedeemedNFT(address,address,address,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _curator?: PromiseOrValue<string> | null,
      _token?: PromiseOrValue<string> | null,
      _tokenId?: null
    ): CuratorRedeemedNFTEventFilter;
    CuratorRedeemedNFT(
      _vault?: PromiseOrValue<string> | null,
      _curator?: PromiseOrValue<string> | null,
      _token?: PromiseOrValue<string> | null,
      _tokenId?: null
    ): CuratorRedeemedNFTEventFilter;

    "FeeDispersed(address,address,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _receiver?: PromiseOrValue<string> | null,
      _amount?: null
    ): FeeDispersedEventFilter;
    FeeDispersed(
      _vault?: PromiseOrValue<string> | null,
      _receiver?: PromiseOrValue<string> | null,
      _amount?: null
    ): FeeDispersedEventFilter;

    "MintedRaes(address,address,uint256,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _quantity?: null,
      _price?: null
    ): MintedRaesEventFilter;
    MintedRaes(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _quantity?: null,
      _price?: null
    ): MintedRaesEventFilter;

    "Refunded(address,address,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _balance?: null
    ): RefundedEventFilter;
    Refunded(
      _vault?: PromiseOrValue<string> | null,
      _user?: PromiseOrValue<string> | null,
      _balance?: null
    ): RefundedEventFilter;

    "RoyaltyPaid(address,address,uint256)"(
      _vault?: PromiseOrValue<string> | null,
      _royaltyReceiver?: PromiseOrValue<string> | null,
      _amount?: null
    ): RoyaltyPaidEventFilter;
    RoyaltyPaid(
      _vault?: PromiseOrValue<string> | null,
      _royaltyReceiver?: PromiseOrValue<string> | null,
      _amount?: null
    ): RoyaltyPaidEventFilter;
  };

  estimateGas: {
    MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    WETH_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    balanceContributed(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceRefunded(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentPrice(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deployVault(
      _modules: PromiseOrValue<string>[],
      _plugins: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      _lpdaInfo: LPDAInfoStruct,
      _token: PromiseOrValue<string>,
      _id: PromiseOrValue<BigNumberish>,
      _mintProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enterBid(
      _vault: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    feeReceiver(overrides?: CallOverrides): Promise<BigNumber>;

    generateMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    generateUnhashedMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAuctionState(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLeaves(overrides?: CallOverrides): Promise<BigNumber>;

    getMinters(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPermissions(overrides?: CallOverrides): Promise<BigNumber>;

    getProof(
      _data: PromiseOrValue<BytesLike>[],
      _node: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoot(
      _data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUnhashedLeaves(overrides?: CallOverrides): Promise<BigNumber>;

    hashLeafPairs(
      _left: PromiseOrValue<BytesLike>,
      _right: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    log2ceil_naive(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    numMinted(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    redeemNFTCurator(
      _vault: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _tokenId: PromiseOrValue<BigNumberish>,
      _erc721TransferProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    refundOwed(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    registry(overrides?: CallOverrides): Promise<BigNumber>;

    settleAddress(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    settleCurator(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(overrides?: CallOverrides): Promise<BigNumber>;

    updateFeeReceiver(
      _receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    vaultLPDAInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    vaultLPDAMinters(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    vaultRoyaltyToken(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    vaultRoyaltyTokenId(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyProof(
      _root: PromiseOrValue<BytesLike>,
      _proof: PromiseOrValue<BytesLike>[],
      _valueToProve: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH_ADDRESS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    balanceContributed(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceRefunded(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    currentPrice(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deployVault(
      _modules: PromiseOrValue<string>[],
      _plugins: PromiseOrValue<string>[],
      _selectors: PromiseOrValue<BytesLike>[],
      _lpdaInfo: LPDAInfoStruct,
      _token: PromiseOrValue<string>,
      _id: PromiseOrValue<BigNumberish>,
      _mintProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enterBid(
      _vault: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    feeReceiver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    generateMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    generateUnhashedMerkleTree(
      _modules: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAuctionState(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLeaves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMinters(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPermissions(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProof(
      _data: PromiseOrValue<BytesLike>[],
      _node: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoot(
      _data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUnhashedLeaves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hashLeafPairs(
      _left: PromiseOrValue<BytesLike>,
      _right: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    log2ceil_naive(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    numMinted(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    redeemNFTCurator(
      _vault: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _tokenId: PromiseOrValue<BigNumberish>,
      _erc721TransferProof: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    refundOwed(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    registry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    settleAddress(
      _vault: PromiseOrValue<string>,
      _minter: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    settleCurator(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateFeeReceiver(
      _receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    vaultLPDAInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    vaultLPDAMinters(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    vaultRoyaltyToken(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    vaultRoyaltyTokenId(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyProof(
      _root: PromiseOrValue<BytesLike>,
      _proof: PromiseOrValue<BytesLike>[],
      _valueToProve: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
